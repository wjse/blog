# MySQL存储引擎

标签（空格分隔）： MySQL

---

> MySQL 5 支持的存储引擎包括MyISAM 、InnoDB 、BDB、MEMORY 、 EXAMPLE 、 NBD Cluster 、
> ARCHIVE 、 CSV 、 BLACKHOLE 、 FEDERATED等
> 
> 支持事务的：
> 
>  - InnoDB
>  - BDB
> 
> 不支持事务的：
> 
>  - MyISAM
>  - MEMORY
>  - EXAMPLE
>  - NBD Cluster
>  - ARCHIVE
>  - CSV
>  - BLACKHOLE
>  - FEDERATED
> 
> 在创建表时如不指定存储引擎，MySQL5.5之前的默认存储引擎是MyISAM，5.5之后改为了InnoDB。
> 如要修改默认的存储引擎，可在参数文件中（my.ini / my.cnf）设置**default-table-type**。
> 通过命令`show engines`查看当前支持的存储引擎

### 1 常用存储引擎对比

|特点|MyISAM|InnoDB|MEMORY|MERGE|NDB|
|:---|:-----|:-----|:-----|:----|:--|
|存储限制|有|64TB|有|没有|有|
|事务安全||支持||
|锁机制|表锁|行锁|表锁|表锁|行锁|
|B Tree索引|支持|支持|支持|支持|支持|
|哈希索引|||支持||支持|
|全文索引|支持|||||
|集群索引||支持||||
|数据缓存||支持|支持||支持|
|索引缓存|支持|支持|支持|支持|支持|
|数据可压缩|支持|||||
|空间使用|低|高|N/A|低|低|
|内存使用|低|高|中等|低|高|
|批量插入的速度|高|低|高|高|高|
|支持外键||支持||||
 
### 2 MyISAM

 
  

>  
MyISAM是MySQL默认的存储引擎(5.5之前)。MyISAM不支持事务、也不支持外键，其优势是访问的速度快，对事务完整性没有要求或者以SELECT、INSERT为主的应用基本上都可以使用这个引擎来创建表。
每个MyISAM在磁盘上存储成3个文件，其文件名都和表名相同，但扩展名分别是：

>  - table_name.frm(存储表定义)
>  - table_name.MYD(MYData , 存储数据)
>  - table_name.MYI(MYIndex , 存储索引)


> 数据文件和索引文件可以放置在不同的目录，平均分布IO，获得更快的速度。
要指定索引文件和数据文件的路径，需要在创建表的时候通过`DATA DIRECTORY` 和 `INDEX DIRECTORY`语句指定 ， 也就是说不同**MyISAM表的索引文件和数据文件可以放置到不同的路径下** 。 文件路径需要是绝对路径 ， 并且具有访问权限。


#### 2.1 MyISAM 存储格式

> MyISAM的表支持3种不同的存储格式，分别是静态（固定长度）表、动态表、压缩表。

##### 2.1.1 静态表

> 静态表是默认的存储格式。静态表中的字段都是**非变长字段**。这样每个记录都是固定长度的，这种存储方式的优点是：**存储非常迅速，容易缓存，出现故障容易恢复**。 缺点是：**占用的空间通常比动态表多** 。 静态表的数据在存储时会按照列的宽度定义补足空格 ，但是在应用访问的时候并不会得到这些空格，这些空格在返回给应用之前已被去掉。

**注意：如果需要存储的内容后面本来就带有空格，那么在返回结果的时候也会被去掉！**

##### 2.1.2 动态表

> 动态表中包含变长字段，记录不是固定长度的，这样存储的优点是：**占用的空间相对较少** ， 缺点是 ：**频繁的更新和删除记录会产生碎片，需要定期执行`OPTIMIZE TABLE 语句或 myisamchk-r`命令来改善性能，并且在出现故障时恢复相对比较困难**

##### 2.1.3 压缩表

> 压缩表由myisampack工具创建，占据非常小的磁盘空间。因为每个记录是被单独压缩的，所以只有非常小的访问开支。

### 3 InnoDB

> InnoDB存储引擎提供了事务安全。但对比MyISAM的存储引擎，InnoDB写的处理效率差一些，并且会占用更多的磁盘空间以保留数据和索引。

InnoDB不同于其他存储引擎的表的特点：

#### 3.1 自动增长列

> InnoDB表的自动增长列可以手工插入，但是插入的值如果是空或者0，则实际插入的将是自动增长后的值。 可以通过`alter table table_name auto_increment = n;`语句强制设置自动增长列的初始值，默认从1开始，但是该强制的默认值是保留在**内存中**，如果该值在使用之前数据库重新启动，那么这个强制的默认值就会丢失，就需要在数据库启动以后重新设置。

> 可以通过`LAST_INSERT_ID()`查询当前线程最后插入记录使用的值。如果一次插入了多条记录，那么返回的是**第一条记录**使用的自动增长值。

> 对于InnoDB表，自动增长列必须是索引。如果是组合索引，也必须是组合索引的第一列，但是对于MyISAM表，自动增长列可以是组合索引的其他列，这样插入记录后，自动增长列是按照组合索引的前面几列进行排序后递增的。


#### 3.2 外键约束

> MySQL支持外键的存储引擎只有InnoDB，在创建外键的时候，要求父表必须有对应的索引，子表在创建外键的时候也会自动创建对应索引。

> 在创建索引时，可以指定在删除，更新父表时，对子表进行相应操作，包括RESTRICT ， CASCADE ， SET NULL 和 NO ACTION。其中RESTRICT和NO ACTION相同，是指限制在子表有关联记录的情况下附表不能更新；CASCADE表示附表在更新或删除时，更新或删除子表对应记录；SET NULL表示父表在更新或删除的时候，子表的对应字段被SET NULL。

#### 3.3 存储方式

> InnoDB存储表和索引有以下两种方式。

> 使用共享表空间存储，这种方式创建的表的结构保存在.frm文件中，但是每个表的数据和索引单独保存在.ibd中。如果是个分区表，则每个分区对应单独的.ibd文件，文件名是“表名+分区名”，可以在创建分区的时候指定每个分区的数据文件的位置，以此来将表的IO均匀分布在多个磁盘上。
> 
> 要使用多表空间的存储方式，需要设置参数innodb_file_per_table并且重新启动服务后才可以生效，对于新建的表按照多表空间的方式创建，已有的表仍然使用共享表空间存储。如果将已有的多表空间方式修改回共享表空间方式，则新建表会在共享表空间中创建，但已有的多表空间的表仍然保存原来的访问方式。所以多表空间的参数生效后，只对新建的表生效。

> 多表空间的数据文件没有大小限制，不需要设置初始大小，也不需要设置文件的最大限制、扩展大小等参数。

### 4 MEMORY

> MEMORY存储引擎使用存在于内存中的内容来创建表。每个MEMORY表只实际对应一个磁盘文件，格式是.frm。MEMORY类型的表访问非常快，因为它的数据是放在内存中，并且默认使用HASH索引，但一旦服务关闭，表中的数据就会丢失掉。
> 
> 服务器需要足够内存来维持所有在同一时间使用的MEMORY表，当不再需要MEMORY表的内容之时，要释放被MEMORY表使用的内存，应该执行DELETE FROM 或 TRUNCATE TABLE ， 或者 DROP TABLE操作。
> 
> 每个MEMORY表中可以放置的数据量的大小，收到max_heap_table_size系统变量的约束，这个系统变量的初始值是16MB，可以根据需要加大。此外，在定义MEMORY表的时候，可以通过MAX_ROWS字句指定表的最大行数。

> MEMORY类型的存储引擎主要用于那些内容变化不频繁的代码表 ， 或者作为统计操作的中间结果表，便于高效地对中间结果进行分析并得到最终的统计结果。对存储引擎为MEMORY的表进行更新操作要谨慎，因为数据并没有实际写入到磁盘中，所以一定要对下次重新启动服务后如何获得这些修改后的数据有所考虑。

### 5 MERGE

> MERGE存储引擎是一组MyISAM表的组合，这些MyISAM表**必须结构完全相同**，MERGE表本身并没有数据，对MERGE类型的表可以进行查询、更新、删除操作，这些操作实际上是对内部的MyISAM表进行的。对于MERGE类型表的插入操作，是通过INSERT_METHOD子句定义插入的表，可以有3个不同的值，使用FIRST或LAST值使得插入操作被相应地作用在第一或最后一个表上，不定义这个字句或定义为NO，表示不能对这个MERGE表执行插入操作。

> 可以对MERGE表进行DROP操作，这个操作知识删除MERGE的定义，对内部的表没有任何的影像。

> MERGE表在磁盘上保留两个文件，文件名以表的名字开始，一个.frm文件存储表定义，另一个.mrg文件包含组合表的信息，包括MERGE表由哪些表组成、插入新的数据时的依据。可以通过修改.MRG文件来修改MERGE表，但是修改后要通过FLUSH TABLES刷新。

> MERGE表和分区表的区别，MERGE表并不能智能的将记录写到对应的表中，而分区表是可以的。通常我们使用MERGE表来透明地对多个表进行查询和更新操作。

### 6 选择合适的存储引擎

> 在选择存储引擎时，应根据应用特点选择合适的存储引擎。对于复制的应用系统，还可以根据实际情况选择多种存储引擎进行组合。

> **MyISAM**：应用是以操作和插入操作为主，只有很少的更新和删除操作，并且对事务的完整性、并发性要求不是很高，那么选择这个存储引擎时非常适合的。MyISAM实在Web，数据仓储和其他应用环境下最常使用的存储引擎之一。

> **InnoDB**：应用对事务的完整性有比较高的要求，在并发条件下要求数据的一致性，数据操作除了插入和查询以外，还包括很多的更新。删除操作，那么InnoDB存储引擎应该是比较适合的选择。InnoDB存储引擎除了有效地降低由于删除和更新导致的锁定，还可以确保事务的完整提交和回滚，对于类似计费系统或者财务系统等对数据准确性要求比较高的系统，InnoDB是合适的选择。

> **MEMORY**：将所有数据保存在RAM中，在需要快速定位记录和其他类似数据的环境下，可提供极快的访问。MEMORY的缺陷是对表的大小有限制，太大的表无法缓存在内存中，其次是要确保标的数据可以恢复，数据库异常终止后表中的数据是可以恢复的。MEMORY表通常用于更新不太频繁的小表，用以快速得到访问结果。

> **MERGE**：用于将一系列等同的MyISAM表以逻辑方式组合在一起，并作为一个对象引用他们。MERGE表的优点在于可以突破对单个MyISAM表大小的限制，并且通过将不同的表分布在多个磁盘上，可以有效地改善MERGE表的访问效率。对于诸如数据仓储等VLDB环境十分适合。
