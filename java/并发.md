# 并发基础

## 1 线程

### 1.1 基础

什么是线程

​    进程表示程序在操作系统中的运行态，而线程是进程中运行的最小单位。

如何创建线程

​    继承`Thread`类重写`run`方法

​    实现`Runnable`接口实现`run`方法

怎样启动线程

​    Thread.start()

​    Executors.newCachedThread()

线程方法

   `sleep()`当前线程进入睡眠，让出cpu资源，sleep完回到就绪（ready）状态

   `yield()`暂时退出，让出一下cpu资源，其他线程能否抢到，不管。

   `join()`当前线程加入另一个线程，当另一个线程执行完成时才继续运行当前线程。

线程状态

​	runnable：ready，running

​	time-waiting

​    waiting

​    blocked

​	terminated

关闭线程

   正常让线程结束，不要stop()线程,interrupt()打断线程来处理逻辑也是不合理的

## 2 synchronized

### 2.1 基础

```java
private Object o = new Object();
public void m(){
  synchronized(o){
    //do something
  }
}
```

1.1 `synchronized`在对象上进行加锁，对象头（64位）里面拿出两位来来记录是否被锁定（mark word），基础数据类型以及`String`不建议用来做对象锁。

用来加锁的对象o改变了，则锁失效，所以对象锁一般都需要加`final`。

```java
public synchronized void m1(){
  
}

public void m2(){
  synchronized(this){
    
  }
}
```

1.2 上面两种方式为等价方式，都是基于`this`对象进行加锁



```java
public class T1{
	public synchronized static void m1(){
  
	}

	public void m2(){
  	synchronized(T1.class){
      
    }
	}
}
```

1.3 静态方法使用`synchronized`等同于使用class对象进行加锁，在同一个ClassLoader中，class对象在内存中为单例。

1.4 在`synchronized`块中所涉及的全局变量不必再使用`volatile`关键字修饰，因为`synchronized`既保证了可见性又保证了原子性。

同步方法和非同步方法是必须可同时调用的，同时`synchronized`必须是可重入锁。



### 2.2 底层实现

JDK早期的实现为重量级，需要到操作系统去申请锁资源。

JDK1.5后，进行了改进，采用了“锁升级”的概念。

锁升级:

```java
private Object o = new Object();

public void m(){
  synchronized(o){
    
  }
}
```

​         

1.markword记录当前访问线程id，并不会去加锁--偏向锁

2.如果有其他线程争用，升级为自旋锁，争用线程占用cpu资源while循环等待，默认while10次（用户态）

3.如果还没得到锁，升级为重量级锁，加入到操作系统的等待队列（内核态）

**所以，执行时间长的或并发数高的使用系统重量级锁（synchronized）；执行时间短或线程数较少使用自旋锁。**



## 3 volatile

### 3.1 基础  

保证线程可见性 ， 基于MESI，CPU缓存一致性协议

禁止指令（汇编指令 ）重排序,CPU原语支持，loadFence ， storeFence 读写屏障：

比如new对象过程

1.申请内存 ， 赋上默认值

2.改为真正的值

3.内存指向赋值 

超高并发下，有可能重排序，则其他线程读到的值为初始化的默认值

volatile不能替代synchronized，应为它并不保证原子性。



## 4 CAS（无锁优化 自旋）

### 4.1 基础

Compare And Set，比较并且设定，基于Unsafe类（Unsafe类似于c++的指针）

Unsafe类主要提供以下几个操作：

​    直接操作内存

​    直接生成实例

​    直接操作类或实例变量

​    CAS相关操作

cas(V , Expected , NewValue){  //V要改的值 ， Expected期望的值 ， 新值

​	if (V == E){ //cpu 原语支持，这个过程不会被打断，所以不存在另一线程将V的值改变

​		V = NewValue

​    }else{

​        //try again or fail

​    }

ABA问题：

a = 1; cas(a , 1 , 2);

如果有其他线程将a变为2又变回为1，就会存在ABA问题，

此时需要加版本号来区分，在比较的时候连版本号一并检查

如果是基础类型，无所谓，引用类型会出现问题