# 并发基础

## 1 线程

### 1.1 基础

什么是线程

​    进程表示程序在操作系统中的运行态，而线程是进程中运行的最小单位。

如何创建线程

​    继承`Thread`类重写`run`方法

​    实现`Runnable`接口实现`run`方法

怎样启动线程

​    Thread.start()

​    Executors.newCachedThread()

线程方法

   `sleep()`当前线程进入睡眠，让出cpu资源，sleep完回到就绪（ready）状态

   `yield()`暂时退出，让出一下cpu资源，其他线程能否抢到，不管。

   `join()`当前线程加入另一个线程，当另一个线程执行完成时才继续运行当前线程。

线程状态

​	runnable：ready，running

​	time-waiting

​    waiting

​    blocked

​	terminated

关闭线程

   正常让线程结束，不要stop()线程,interrupt()打断线程来处理逻辑也是不合理的

## 2 synchronized

### 2.1 基础

```java
private Object o = new Object();
public void m(){
  synchronized(o){
    //do something
  }
}
```

1.1 `synchronized`在对象上进行加锁，对象头（64位）里面拿出两位来来记录是否被锁定（mark word），基础数据类型以及`String`不建议用来做对象锁。

```java
public synchronized void m1(){
  
}

public void m2(){
  synchronized(this){
    
  }
}
```

1.2 上面两种方式为等价方式，都是基于`this`对象进行加锁



```java
public class T1{
	public synchronized static void m1(){
  
	}

	public void m2(){
  	synchronized(T1.class){
      
    }
	}
}
```

1.3 静态方法使用`synchronized`等同于使用class对象进行加锁，在同一个ClassLoader中，class对象在内存中为单例。

1.4 在`synchronized`块中所涉及的全局变量不必再使用`volatile`关键字修饰，因为`synchronized`既保证了可见性又保证了原子性。

同步方法和非同步方法是必须可同时调用的，同时`synchronized`必须是可重入锁。



### 2.2 底层实现

JDK早期的实现为重量级，需要到操作系统去申请锁资源。

JDK1.5后，进行了改进，采用了“锁升级”的概念。

锁升级:

```java
private Object o = new Object();

public void m(){
  synchronized(o){
    
  }
}
```

​         

1.markword记录当前访问线程id，并不会去加锁--偏向锁

2.如果有其他线程争用，升级为自旋锁，争用线程占用cpu资源while循环等待，默认while10次（用户态）

3.如果还没得到锁，升级为重量级锁，加入到操作系统的等待队列（内核态）

**所以，执行时间长的或并发数高的使用系统重量级锁（synchronized）；执行时间短或线程数较少使用自旋锁。**