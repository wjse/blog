# 并发基础

## 1 线程



## 2 synchronized

### 2.1 基础

```java
private Object o = new Object();
public void m(){
  synchronized(o){
    //do something
  }
}
```

1.1 `synchronized`在对象上进行加锁，对象头（64位）里面拿出两位来来记录是否被锁定（mark word），基础数据类型以及`String`不建议用来做对象锁。

```java
public synchronized void m1(){
  
}

public void m2(){
  synchronized(this){
    
  }
}
```

1.2 上面两种方式为等价方式，都是基于`this`对象进行加锁



```java
public class T1{
	public synchronized static void m1(){
  
	}

	public void m2(){
  	synchronized(T1.class){
      
    }
	}
}
```

1.3 静态方法使用`synchronized`等同于使用class对象进行加锁，在同一个ClassLoader中，class对象在内存中为单例。

1.4 在`synchronized`块中所涉及的全局变量不必再使用`volatile`关键字修饰，因为`synchronized`既保证了可见性又保证了原子性。

同步方法和非同步方法是必须可同时调用的，同时`synchronized`必须是可重入锁。



### 2.2 底层实现

JDK早期的实现为重量级，需要到操作系统去申请锁资源。

JDK1.5后，进行了改进，采用了“锁升级”的概念。

锁升级:

           ```java
private Object o = new Object();

public void m(){
  synchronized(o){
    
  }
}
           ```

1.markword记录当前访问线程id，并不会去加锁--偏向锁

2.如果有其他线程争用，升级为自旋锁，争用线程占用cpu资源while循环等待，默认while10次（用户态）

3.如果还没得到锁，升级为重量级锁，加入到操作系统的等待队列（内核态）

**所以，执行时间长的或并发数高的使用系统重量级锁（synchronized）；执行时间短或线程数较少使用自旋锁。**